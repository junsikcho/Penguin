'''
파일 입출력의 심화 내용
1) 파일 입출력에서 예외 처리와 파일 포인터의 개념을 설명할 수 있다.
2) 스트림과 버퍼링을 활용하여 대용량 데이터를 효율적으로 처리하는 방법을 구현할 수 있다.
'''

## 파일 및 디렉터리 다루기
# shutil 모듈과 os 모듈, os.path모듈 : 파일. 디렉터리(폴더) 다룰 수 있는 다양한 함수 제공

import shutil
dir(shutil)

#+======================================================================================

## 파일 및 디렉터리 다루기
# shutil 모듈과 os 모듈, os.path모듈 : 파일. 디렉터리(폴더) 다룰 수 있는 다양한 함수 제공

import os
dir(os)


#========================================================================================

## 파일 및 디렉터리 다루기
# shutil 모듈과 os 모듈, os.path모듈 : 파일. 디렉터리(폴더) 다룰 수 있는 다양한 함수 제공

import os.path
dir(os.path)

#+=========================================================================================

## 파일 및 디렉터리 다루기
# shutil.copy(소스파일, 타깃파일) 함수 사용
import shutil
shutil.copy('C:/Windows/notepad.exe', 'C:/Temp/myNote.exe')

'''
1) 복사할 때는 원본 파일이 있어야 하고, 복사하려는 폴더(C:\Temp)도 있어야 함.
'''
# 2) 디렉터리 통째로 복사
shutil.copytree('C:/CookPython/GIF/', 'C:/Temp/GIF')

#==========================================================================================

## 파일 및 디렉터리 다루기
# 디렉터리의 생성 및 삭제
# 1) 디렉터리의 생성 : os.mkdir(폴더명) 함수 사용
# 2) 디렉터리의 삭제 : shutil.rmtree(폴더명) 함수 사용
import os
import shutil
os.mkdir('C:/myDir/')
os.mkdir('C:/myDir/dir1/')
shutil.rmtree('C:/myDir/')
'''
1) os.mkdir(폴더명)함수 : 미리 상위 폴더 만들어야 함
2) 51행을 먼저 실행하지 않고 52행을 실행하면 오류 발생
3) shutil.rmtree(폴더명) 함수는 폴더 안의 모든 파일 삭제
'''

#=================================================================================================

## 파일 및 디렉터리 다루기
# 디렉터리의 목록 모두 보기
# 1) os.walk(폴더) 함수 사용

import os
for dirName, subDirList, fnames in os.walk('C:\\Windows\\debug') :
    for fname in fnames :
        os.path.join(dirName, fname)

'''
코드 설명
67행 : os.walk(폴더) 함수는 현재  폴더명(dirName), 
현재 폴더의 하위 디렉터리 목록(subDirList), 파일명 목록(fnames) 3개를 반환

68 ~ 69헹 : fnames의 개수만큼 반복해서 폴더명과 파일명 묶어 출력
'''    

#==================================================================================================

## 파일 및 디렉터리 다루기
# 파일 또는 폴더가 이미 존재하는지 확인
# 1) os.path.exists(파일명 또는 폴더명) 사용

import os.path
os.path.exists('C:/Windows/notepad.exe')
os.path.isfile('C:/Windows/notepad.exe')
os.path.isdir('C:/Windows')

#===========================================================================================

## 파일 및 디렉터리 다루기
# 파일 삭제
import os
os.remove('C:/Temp/myNote.exe')
os.remove('C:/Temp/myNote.exe')

#=================================================================================================

## 파일 및 디렉터리 다루기
# 파일 크기 확인(바이트 단위로 출력)
import os.path
os.path.getsize('C:/Python/CookPython/GIF/dog.gif')

#==========================================================================================

## 파일 및 디렉터리 다루기
# 파일 압축과 압축 풀기
# 1) 압축 기능은 zipfile 모듈에서 제공
import zipfile
newZip = zipfile.ZipFile('C:/Temp/new.zip', 'w')
newZip.write('C:/Windows/notepad.exe', compress_type = zipfile.ZIP_DEFLATED)
newZip.close()

'''
코드 설명
111행 : 새로 압축될 파일을 쓰기(w)로 준비
112행 : 압축수행
113행 : 압축 파일닫기
출력 결과는 정상적으로 처리되면 아무런 메시지도 표시되지 않음
'''

#===========================================================================================

## 파일 및 디렉터리 다루기
# 파일 압축과 압축 풀기
# 1) 압축 풀기
extZip = zipfile.ZipFile('C:/Temp/new.zip', 'r')
extZip.extractall('C:/Temp/')
extZip.close()

'''
코드 설명
128행 : 압축 풀 파일을 읽기(r)로준비
129행 : 해당 폴더에 압축 풀기
130행 : 압출 파일 닫기
출력 결과는 정상적으로 처리되면 아무런 메시지도 표시되지 않음.
'''

#============================================================================================

## 예외 처리
# try, except 문
# 예외 처리(Exception Handling) : 오류가 발생할 때 파이썬이 처리하지 않고
# 프로그래머가 작성한 코드를 실행하는 방식
import os
os.remove('C:/Temp/noFile.exe') # 이 파일이 없음

#===============================================================================================

## 예외 처리
# try문, except 문을 활용, 이런 파이썬의 오류 대신 직접 오류 메시지를 작성 정상적으로 흐름을 이어가게 함.
try:
    os.remove('C:/Temp/noFile.exe')
except:
    print('파일이 없네요. 확인 바랍니다.')

#+==================================================================================================

## 예외 처리
# 문자열 중에서 '파이썬' 글자의 위치를 모두 찾아서 출력하는 코드
# 1) '파이썬' 글자가 위치한 첨자 0과 13을 찾은 후에는 더 이상 읽기 때문에 오류가 발생
#Code11-13.py
myStr = '파이썬은 재미 있어요. 파이썬만 매일매일 공부하고 싶어요.^^'
strPosList = []
index = 0

while True :
    index = myStr.index('파이썬', index)
    strPosList.append(index)
    index = index + 1 #다음 위치부터 찾음
    
print('파이썬 글자 위치 -->', strPosList)

#======================================================================================================

## 예외 처리
# 문자열 중에서 '파이썬' 글자의 위치를 모두 찾아서 출력하는 코드
# 1) 예외 처리 추가
#Code11-14.py
myStr = '파이썬은 재미 있어요. 파이썬만 매일매일 공부하고 싶어요.^^'
strPosList = []
index = 0

while True :
    try :
        index = myStr.index('파이썬', index)
        strPosList.append(index)
        index = index + 1 #다음 위치부터 찾음
    except :
        break
    
print('파이썬 글자 위치 -->', strPosList)

#+========================================================================================================

## 예외 처리
# 문자열 중에서 '파이썬' 글자의 위치를 모두 찾아서 출력하는 코드
# 1) except 문 뒤에 아무것도 명시하지 않으면 모든 종류의 오류 처리
# -> 필요하다면 오류의 종류에 따라서 다른 오류 처리도 가능
'''
try :
    실행할 문장들
except 예외_종류 1:
    오류일 때 실행할 문장들
excepy 예외_종류 2:
    오류일 때 실행할 문장들
'''

#===============================================================================================

### 예외 처리
# 오류의 종류에 따라서 다른 처리를 진행하는 코드
#Code11-15.py
num1 = input('숫자1-->')
num2 = input('숫자2-->')

try :
    num1=int(num1)
    num2=int(num2)
    while True :
        res = num1 / num2
        
except ValueError :
    print('문자열은 숫자로 변환할 수 없습니다.')
    
except ZeroDivisionError:
    print('0으로 나눌 수 없습니다.')
    
except KeyboardInterrupt:
    print('Ctrl+C를 눌렀군요.')

#==========================================================================================

'''
예외 처리
try, except, else, finally 문
1) try문에서 오류가 발생하면 except문이 실행
2) 오류가 발생하지 않으면 else 문이 실행
3) finally문은 오류가 발생하든 그렇지 않든 무조건 실행
'''

#==========================================================================================

## 예외 처리
# try, except, else, finally 문
#Code11-16.py
num1 = input('숫자1-->')
num2 = input('숫자2-->')

try :
    num1=int(num1)
    num2=int(num2)
        
except :
    print('오류가 발생했습니다.')
    
else :
    print(num1, '/', num2, '=', num1/num2)
    
finally :
    print('이 부분은 무조건 나옵니다.')
